void selfconsistent(); //関数のプロトタイプ宣言

void selfconsistent()
{
  #define SIZE 7         //7*7型の行列
  char jobvl = 'N';      //左固有ベクトルは計算しない
  char jobvr = 'V';      //右固有ベクトルは計算する
  int  N = SIZE;         //対角化する正方格子のサイズ
  double Ham[SIZE*SIZE]; //対角化する行列
  int lda = SIZE;        //対角化する正方行列のサイズ
  double wr[SIZE];       //実固有値が入る
  double wi[SIZE];       //複素固有値が入る
  double vl[SIZE*SIZE];  //左固有ベクトルが入る
  int ldvl = SIZE;       //左固有ベクトルの本数
  double vr[SIZE*SIZE];  //右固有ベクトルが入る
  int ldvr = SIZE;       //右固有ベクトルの本数
  double work[16*SIZE];  //対角化する際に使用するメモリ
  int lwork = 4*SIZE;    //workの次元
  int info;              //成功すれば0 失敗すれば0以外を返す
  int i,j=0;             //カウント数
  double b[SIZE*SIZE];   //消滅演算子
  double b2[SIZE*SIZE];  //生成演算子
  double n[SIZE*SIZE];   //粒子数演算子
  double n2[SIZE*SIZE];  //粒子数演算子の二乗
  double one[SIZE*SIZE]; //単位演算子
  double min;     //最低固有値
  double a[SIZE]; //最低固有値の固有ベクトルの成分

  //消滅演算子の行列表示
  b[0]=0;b[7]=1; b[14]=0;      b[21]=0;      b[28]=0;      b[35]=0;      b[42]=0;
  b[1]=0;b[8]=0; b[15]=sqrt(2);b[22]=0;      b[29]=0;      b[36]=0;      b[43]=0;
  b[2]=0;b[9]=0; b[16]=0;      b[23]=sqrt(3);b[30]=0;      b[37]=0;      b[44]=0;
  b[3]=0;b[10]=0;b[17]=0;      b[24]=0;      b[31]=sqrt(4);b[38]=0;      b[45]=0;
  b[4]=0;b[11]=0;b[18]=0;      b[25]=0;      b[32]=0;      b[39]=sqrt(5);b[46]=0;
  b[5]=0;b[12]=0;b[19]=0;      b[26]=0;      b[33]=0;      b[40]=0;      b[47]=sqrt(6);
  b[6]=0;b[13]=0;b[20]=0;      b[27]=0;      b[34]=0;      b[41]=0;      b[48]=0;
  //生成演算子の行列表示
  b2[0]=0;b2[7]=0;       b2[14]=0;      b2[21]=0;      b2[28]=0;      b2[35]=0;      b2[42]=0;
  b2[1]=1;b2[8]=0;       b2[15]=0;      b2[22]=0;      b2[29]=0;      b2[36]=0;      b2[43]=0;
  b2[2]=0;b2[9]=sqrt(2); b2[16]=0;      b2[23]=0;      b2[30]=0;      b2[37]=0;      b2[44]=0;
  b2[3]=0;b2[10]=0;      b2[17]=sqrt(3);b2[24]=0;      b2[31]=0;      b2[38]=0;      b2[45]=0;
  b2[4]=0;b2[11]=0;      b2[18]=0;      b2[25]=sqrt(4);b2[32]=0;      b2[39]=0;      b2[46]=0;
  b2[5]=0;b2[12]=0;      b2[19]=0;      b2[26]=0;      b2[33]=sqrt(5);b2[40]=0;      b2[47]=0;
  b2[6]=0;b2[13]=0;      b2[20]=0;      b2[27]=0;      b2[34]=0;      b2[41]=sqrt(6);b2[48]=0;
  //粒子数演算子の行列表示
  n[0]=0;n[7]=0; n[14]=0;n[21]=0;n[28]=0;n[35]=0;n[42]=0;
  n[1]=0;n[8]=1; n[15]=0;n[22]=0;n[29]=0;n[36]=0;n[43]=0;
  n[2]=0;n[9]=0; n[16]=2;n[23]=0;n[30]=0;n[37]=0;n[44]=0;
  n[3]=0;n[10]=0;n[17]=0;n[24]=3;n[31]=0;n[38]=0;n[45]=0;
  n[4]=0;n[11]=0;n[18]=0;n[25]=0;n[32]=4;n[39]=0;n[46]=0;
  n[5]=0;n[12]=0;n[19]=0;n[26]=0;n[33]=0;n[40]=5;n[47]=0;
  n[6]=0;n[13]=0;n[20]=0;n[27]=0;n[34]=0;n[41]=0;n[48]=6;
  //粒子数二乗演算子の行列表示
  n2[0]=0;n2[7]=0; n2[14]=0;n2[21]=0;n2[28]=0; n2[35]=0; n2[42]=0;
  n2[1]=0;n2[8]=1; n2[15]=0;n2[22]=0;n2[29]=0; n2[36]=0; n2[43]=0;
  n2[2]=0;n2[9]=0; n2[16]=4;n2[23]=0;n2[30]=0; n2[37]=0; n2[44]=0;
  n2[3]=0;n2[10]=0;n2[17]=0;n2[24]=9;n2[31]=0; n2[38]=0; n2[45]=0;
  n2[4]=0;n2[11]=0;n2[18]=0;n2[25]=0;n2[32]=16;n2[39]=0; n2[46]=0;
  n2[5]=0;n2[12]=0;n2[19]=0;n2[26]=0;n2[33]=0; n2[40]=25;n2[47]=0;
  n2[6]=0;n2[13]=0;n2[20]=0;n2[27]=0;n2[34]=0; n2[41]=0; n2[48]=36;
  //単位演算子の行列表示
  one[0]=1;one[7]=0; one[14]=0;one[21]=0;one[28]=0;one[35]=0;one[42]=0;
  one[1]=0;one[8]=1; one[15]=0;one[22]=0;one[29]=0;one[36]=0;one[43]=0;
  one[2]=0;one[9]=0; one[16]=1;one[23]=0;one[30]=0;one[37]=0;one[44]=0;
  one[3]=0;one[10]=0;one[17]=0;one[24]=1;one[31]=0;one[38]=0;one[45]=0;
  one[4]=0;one[11]=0;one[18]=0;one[25]=0;one[32]=1;one[39]=0;one[46]=0;
  one[5]=0;one[12]=0;one[19]=0;one[26]=0;one[33]=0;one[40]=1;one[47]=0;
  one[6]=0;one[13]=0;one[20]=0;one[27]=0;one[34]=0;one[41]=0;one[48]=1;

  //平均場ハミルトニアンの行列表示
  for(i=0;i<=48;i++) Ham[i]=-J*z*phinew*(b[i]+b2[i]-phinew*one[i])+(U/2)*n[i]*(n[i]-1)-myu*n[i];
  //平均場ハミルトニアンの対角化
  dgeev_(&jobvl,&jobvr,&N,Ham,&lda,wr,wi,vl,&ldvl,vr,&ldvr,work,&lwork,&info);
  //最低固有値を取り出す
  min = wr[0];
  for(i=1;i<=6;i++){
   if(wr[i]<min){
    min=wr[i]; //最低固有値
    j=i; //最低固有値が何番目にあるか
   }
  }
  //最低固有値の固有ベクトル(a0,a1,a2,a3,a4,a5,a6)を取り出す
  a[0] = vr[7*j];
  a[1] = vr[7*j+1];
  a[2] = vr[7*j+2];
  a[3] = vr[7*j+3];
  a[4] = vr[7*j+4];
  a[5] = vr[7*j+5];
  a[6] = vr[7*j+6];

  // printf("wr[0] = %12.9lf\n",wr[0]);
  // printf("wr[1] = %12.9lf\n",wr[1]);
  // printf("wr[2] = %12.9lf\n",wr[2]);
  // printf("wr[3] = %12.9lf\n",wr[3]);
  // printf("wr[4] = %12.9lf\n",wr[4]);
  // printf("wr[5] = %12.9lf\n",wr[5]);
  // printf("wr[6] = %12.9lf\n",wr[6]);
  //
  // printf("a[0] = %12.9lf\n",a[0]);
  // printf("a[1] = %12.9lf\n",a[1]);
  // printf("a[2] = %12.9lf\n",a[2]);
  // printf("a[3] = %12.9lf\n",a[3]);
  // printf("a[4] = %12.9lf\n",a[4]);
  // printf("a[5] = %12.9lf\n",a[5]);
  // printf("a[6] = %12.9lf\n",a[6]);

  //平均場の更新 ψ=<Φ|b|Φ>
  phinew = a[0]*a[1]+sqrt(2)*a[1]*a[2]+sqrt(3)*a[2]*a[3]
           +sqrt(4)*a[3]*a[4]+sqrt(5)*a[4]*a[5]+sqrt(6)*a[5]*a[6];
}
